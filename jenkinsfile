pipeline {
    agent any
    environment {
        PROJECT_ID = 'bright-airport-463914-a8'
        REGION     = 'europe-west10'          // Berlin region
        ZONE       = 'europe-west10-a'
        IMAGE_NAME = 'hamza3366/abctechnologies'
        SSH_PUBLIC_KEY_PATH = "${env.HOME}/.ssh/id_rsa.pub" // safer dynamic path
    }

    stages {
        stage('Checkout') {
            steps {
                git 'https://github.com/HamzaF3366/IGP_Project_CI-CD.git'
            }
        }

        stage('Compile') {
            steps {
                sh 'mvn compile'
            }
        }

        stage('Test') {
            steps {
                sh 'mvn test'
            }
        }

        stage('Build') {
            steps {
                sh 'mvn package'
            }
        }

        stage('Build & Push Docker image') {
            steps {
                script {
                    def imageTag = "${IMAGE_NAME}:${env.BUILD_NUMBER}"
                    withDockerRegistry([credentialsId: "mydockerhubcred", url: ""]) {
                        sh "docker build -t ${imageTag} ."
                        sh "docker push ${imageTag}"
                    }
                }
            }
        }

        stage('Terraform: Create GCP VMs') {
            steps {
                withCredentials([file(credentialsId: 'gcp-service-account', variable: 'GCP_SA')]) {
                    sh '''
                        export GOOGLE_APPLICATION_CREDENTIALS=$GCP_SA
                        cd terraform
                        terraform init -input=false

                        # Read public key safely
                        if [ ! -f "$SSH_PUBLIC_KEY_PATH" ]; then
                          echo "ERROR: Public key not found at $SSH_PUBLIC_KEY_PATH"
                          exit 1
                        fi
                        PUB_KEY=$(cat "$SSH_PUBLIC_KEY_PATH")

                        terraform apply -auto-approve -input=false \
                            -var "project_id=${PROJECT_ID}" \
                            -var "region=${REGION}" \
                            -var "zone=${ZONE}" \
                            -var "jenkins_ssh_pub=$PUB_KEY"

                        terraform output -json > ../terraform_outputs.json
                        cd ..
                    '''
                }
            }
        }

stage('Ansible: configure k8s cluster') {
    steps {
        withCredentials([sshUserPrivateKey(credentialsId: 'jenkins_ssh_key', keyFileVariable: 'SSH_KEY', usernameVariable: 'SSH_USER')]) {
            sh '''
chmod 600 $SSH_KEY
export ANSIBLE_HOST_KEY_CHECKING=False

# Load Terraform outputs
MASTER_IP=$(python3 -c "import json; j=__import__('json').load(open('terraform_outputs.json')); print(j['master_public_ip']['value'])")
WORKER_IPS=$(python3 -c "import json; j=__import__('json').load(open('terraform_outputs.json')); print(' '.join(j['worker_public_ips']['value']))")

# Wait for master SSH
until ssh -o StrictHostKeyChecking=no -i $SSH_KEY ubuntu@$MASTER_IP 'echo ok'; do
    echo "Waiting for SSH on master ($MASTER_IP)..."
    sleep 20
done

# Wait for worker SSHs
for ip in $WORKER_IPS; do
    until ssh -o StrictHostKeyChecking=no -i $SSH_KEY ubuntu@$ip 'echo ok'; do
        echo "Waiting for SSH on worker ($ip)..."
        sleep 10
    done
done

# Generate Ansible inventory
python3 ansible/generate_inventory.py

# Run Ansible
  ansible-playbook -i ansible/inventory.ini ansible/playbook.yml \
  --private-key $SSH_KEY -u ubuntu -v \
  -e 'ansible_ssh_common_args="-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"'

'''
        }
    }
}



   stage('Deploy Application on Kubernetes') {
    steps {
        withCredentials([sshUserPrivateKey(credentialsId: 'jenkins_ssh_key', keyFileVariable: 'SSH_KEY', usernameVariable: 'SSH_USER')]) {
            sh '''
                MASTER_IP=$(python3 -c "import json; j=__import__('json').load(open('terraform_outputs.json')); print(j['master_public_ip']['value'])")
                
                # Wait for API server to be ready
                until ssh -o StrictHostKeyChecking=no -i $SSH_KEY $SSH_USER@$MASTER_IP "sudo kubectl get nodes --kubeconfig /etc/kubernetes/admin.conf"; do
                    echo "Waiting for Kubernetes API on master ($MASTER_IP)..."
                    sleep 20
                done
                
                # Deploy application directly via SSH on master
                ssh -o StrictHostKeyChecking=no -i $SSH_KEY $SSH_USER@$MASTER_IP << 'EOF'
                    export KUBECONFIG=/etc/kubernetes/admin.conf

                    kubectl apply -f /home/ubuntu/workspace/IGP_Project_CI-CD/k8s/deployment.yml
                    kubectl apply -f /home/ubuntu/workspace/IGP_Project_CI-CD/k8s/service.yml

                    kubectl set image deployment/abctechnologies abc=hamza3366/abctechnologies:${BUILD_NUMBER} --record

                    echo "Current pods status:"
                    kubectl get pods -o wide
EOF
            '''
        }
    }
}

    }

    post {
        always {
            archiveArtifacts artifacts: 'target/*.war', fingerprint: true
        }
    }
}
